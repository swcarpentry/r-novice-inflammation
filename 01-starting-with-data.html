<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Software Carpentry: Programming with R</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="stylesheet" href="css/bootstrap/bootstrap.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="css/bootstrap/bootstrap-responsive.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <link rel="alternate" type="application/rss+xml" title="Software Carpentry Blog" href="http://software-carpentry.org/feed.xml"/>
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="banner">
        <a href="http://software-carpentry.org" title="Software Carpentry">
          <img alt="Software Carpentry banner" src="img/software-carpentry-banner.png" />
        </a>
      </div>
      <div class="row-fluid">
        <div class="span10 offset1">
          <h1 class="title">Programming with R</h1>
          <h2 class="subtitle">Analyzing patient data</h2>
<div id="objectives" class="objectives">
<h2>Objectives</h2>
<ul>
<li>Read tabular data from a file into a program.</li>
<li>Assign values to variables.</li>
<li>Select individual values and subsections from data.</li>
<li>Perform operations on a data frame of data.</li>
<li>Understand Factors</li>
</ul>
</div>
<p>We are studying micro-aneurisms in the eyes of people with diabetes, 100 patients have been sampled anually. The data sets are stored in <a href="../../gloss.html#comma-separeted-values">comma-separated values</a> (CSV) format: each row holds information for a single patient, and the columns represent different observations. The first few rows of our first file look like this:</p>
<pre class="output"><code>ID,Gender,Group,BloodPressure,Age,Aneurisms_q1,Aneurisms_q2,Aneurisms_q3,Aneurisms_q4
Sub001,m,Control,132,16,114,140,202,237
Sub002,m,Treatment2,139,17.2,148,209,248,248
Sub003,m,Treatment2,130,19.5,196,251,122,177
Sub004,f,Treatment1,105,15.7,199,140,233,220
Sub005,m,Treatment1,125,19.9,188,120,222,228
</code></pre>
<p>We want to:</p>
<ul>
<li>load that data into memory,</li>
<li>calculate the average number of aneurisms per eye across all patients, and</li>
<li>plot the result.</li>
</ul>
<p>To do all that, we'll have to learn a little bit about programming.</p>
<h3 id="loading-data">Loading Data</h3>
<p>To load our inflammation data, first we need to locate our data. We can change the current working directory to the location of the CSV files using the function <code>setwd</code>. For example, if the CSV files are located in a directory named <code>swc</code> in our home directory, we would change the working directory using the following command:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setwd</span>(<span class="st">&quot;~/swc/&quot;</span>)</code></pre>
<p>Just like in the Unix Shell, we type the command and then press <code>Enter</code> (or <code>return</code>). Alternatively you can change the working directory using the RStudio GUI using the menu option <code>Session</code> -&gt; <code>Set Working Directory</code> -&gt; <code>Choose Directory...</code></p>
<p>Now we could load the data into R using <code>read.csv</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read.csv</span>(<span class="dt">file =</span> <span class="st">&quot;data/Site-01.csv&quot;</span>, <span class="dt">header =</span> <span class="ot">TRUE</span>)</code></pre>
<p>The expression <code>read.csv(...)</code> is a <a href="reference.html#function-call">function call</a> that asks R to run the function <code>read.csv</code>.</p>
<p><code>read.csv</code> has two <a href="../../gloss.html#argument">arguments</a>: the name of the file we want to read, and whether the first line of the file contains names for the columns of data. The filename needs to be a character string (or <a href="../../gloss.html#string">string</a> for short), so we put it in quotes. Assigning the second argument, <code>header</code>, to be <code>TRUE</code> indicates that the data file does have column headers. We'll talk more about the value <code>TRUE</code>, and its converse <code>FALSE</code>, in lesson 04.</p>
<div id="tip" class="callout">
<h2>Tip</h2>
<p><code>read.csv</code> actually has many more arguments that you may find useful when importing your own data in the future. You can learn more about these options in this supplementary <a href="01-supp-read-write-csv.html">lesson</a>.</p>
</div>
<p>The utility of a function is that it will perform its given action on whatever value is passed to the named argument(s). For example, in this case if we provided the name of a different file to the argument <code>file</code>, <code>read.csv</code> would read it instead. We'll learn more of the details about functions and their arguments in the next lesson.</p>
<p>Since we didn't tell it to do anything else with the function's output, the console will display the full contents of the file <code>inflammation-01.csv</code>. Try it out.</p>
<p><code>read.csv</code> read the file, but didn't save the data in memory. To do that, we need to assign the data frame to a variable. A variable is just a name for a value, such as <code>x</code>, <code>current_temperature</code>, or <code>subject_id</code>. We can create a new variable simply by assigning a value to it using <code>&lt;-</code></p>
<pre class="sourceCode r"><code class="sourceCode r">weight_kg &lt;-<span class="st"> </span><span class="dv">55</span></code></pre>
<p>Once a variable has a value, we can print it by typing the name of the variable and hitting <code>Enter</code> (or <code>return</code>). In general, R will print to the console any object returned by a function or operation <em>unless</em> we assign it to a variable.</p>
<pre class="sourceCode r"><code class="sourceCode r">weight_kg</code></pre>
<pre class="output"><code>[1] 55
</code></pre>
<p>We can do arithmetic with the variable:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># weight in pounds:</span>
<span class="fl">2.2</span> *<span class="st"> </span>weight_kg</code></pre>
<pre class="output"><code>[1] 121
</code></pre>
<div id="tip-1" class="callout">
<h2>Tip</h2>
<p>We can add comments to our code using the <code>#</code> character. It is useful to document our code in this way so that others (and us the next time we read it) have an easier time following what the code is doing.</p>
</div>
<p>We can also change an object's value by assigning it a new value:</p>
<pre class="sourceCode r"><code class="sourceCode r">weight_kg &lt;-<span class="st"> </span><span class="fl">57.5</span>
<span class="co"># weight in kilograms is now</span>
weight_kg</code></pre>
<pre class="output"><code>[1] 57.5
</code></pre>
<p>If we imagine the variable as a sticky note with a name written on it, assignment is like putting the sticky note on a particular value:</p>
<p><img src="fig/python-sticky-note-variables-01.svg" alt="Variables as Sticky Notes" /></p>
<p>This means that assigning a value to one object does not change the values of other variables. For example, let's store the subject's weight in pounds in a variable:</p>
<pre class="sourceCode r"><code class="sourceCode r">weight_lb &lt;-<span class="st"> </span><span class="fl">2.2</span> *<span class="st"> </span>weight_kg
<span class="co"># weight in kg...</span>
weight_kg</code></pre>
<pre class="output"><code>[1] 57.5
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># ...and in pounds</span>
weight_lb</code></pre>
<pre class="output"><code>[1] 126.5
</code></pre>
<p><img src="fig/python-sticky-note-variables-02.svg" alt="Creating Another Variable" /></p>
<p>and then change <code>weight_kg</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">weight_kg &lt;-<span class="st"> </span><span class="fl">100.0</span>
<span class="co"># weight in kg now...</span>
weight_kg</code></pre>
<pre class="output"><code>[1] 100
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># ...and in weight pounds still</span>
weight_lb</code></pre>
<pre class="output"><code>[1] 126.5
</code></pre>
<p><img src="fig/python-sticky-note-variables-03.svg" alt="Updating a Variable" /></p>
<p>Since <code>weight_lb</code> doesn't &quot;remember&quot; where its value came from, it isn't automatically updated when <code>weight_kg</code> changes. This is different from the way spreadsheets work.</p>
<p>Now that we know how to assign things to variables, let's re-run <code>read.csv</code> and save its result:</p>
<pre class="sourceCode r"><code class="sourceCode r">dat &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="dt">file =</span> <span class="st">&quot;data/Site-01.csv&quot;</span>, <span class="dt">header =</span> <span class="ot">TRUE</span>)</code></pre>
<p>This statement doesn't produce any output because assignment doesn't display anything. If we want to check that our data has been loaded, we can print the variable's value. However, for large data sets it is convenient to use the function <code>head</code> to display only the first few rows of data.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(dat)</code></pre>
<pre class="output"><code>      ID Gender      Group BloodPressure  Age Aneurisms_q1 Aneurisms_q2
1 Sub001      m    Control           132 16.0          114          140
2 Sub002      m Treatment2           139 17.2          148          209
3 Sub003      m Treatment2           130 19.5          196          251
4 Sub004      f Treatment1           105 15.7          199          140
5 Sub005      m Treatment1           125 19.9          188          120
6 Sub006      M Treatment2           112 14.3          260          266
  Aneurisms_q3 Aneurisms_q4
1          202          237
2          248          248
3          122          177
4          233          220
5          222          228
6          320          294
</code></pre>
<div id="challenge" class="challenge">
<h2>Challenge</h2>
<p>Draw diagrams showing what variables refer to what values after each statement in the following program:</p>
<pre class="sourceCode r"><code class="sourceCode r">mass &lt;-<span class="st"> </span><span class="fl">47.5</span>
age &lt;-<span class="st"> </span><span class="dv">122</span>
mass &lt;-<span class="st"> </span>mass *<span class="st"> </span><span class="fl">2.0</span>
age &lt;-<span class="st"> </span>age -<span class="st"> </span><span class="dv">20</span></code></pre>
</div>
<h3 id="examining-the-data-structure">Examining the data structure</h3>
<p>Now that our data is in memory, we can start doing things with it. First, let's ask what type of thing <code>dat</code> <em>is</em>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(dat)</code></pre>
<pre class="output"><code>[1] &quot;data.frame&quot;
</code></pre>
<p>The output tells us that data currently is a data frame in R. This is similar to a spreadsheet in MS Excel that many of us are familiar with using. Data frames are very useful for storing data because you can have a continuous variable, e.g. rainfall, in one column and a categorical variable, e.g. month, in another.</p>
<h3 id="column-types">Column types</h3>
<p>A data frame is made up of columns of data. The columns do not have to have the same type.</p>
<p>We can use the <code>class()</code> function to examine a single column.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(dat[,<span class="dv">1</span>])</code></pre>
<pre class="output"><code>[1] &quot;factor&quot;
</code></pre>
<p>The type <code>factor</code> is a very useful column type in R.</p>
<p>The function <code>str()</code> gives information about all the columns in a dataframe.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(dat)</code></pre>
<pre class="output"><code>&#39;data.frame&#39;:   100 obs. of  9 variables:
 $ ID           : Factor w/ 100 levels &quot;Sub001&quot;,&quot;Sub002&quot;,..: 1 2 3 4 5 6 7 8 9 10 ...
 $ Gender       : Factor w/ 4 levels &quot;F&quot;,&quot;f&quot;,&quot;M&quot;,&quot;m&quot;: 4 4 4 2 4 3 2 4 4 2 ...
 $ Group        : Factor w/ 3 levels &quot;Control&quot;,&quot;Treatment1&quot;,..: 1 3 3 2 2 3 1 3 3 1 ...
 $ BloodPressure: int  132 139 130 105 125 112 173 108 131 129 ...
 $ Age          : num  16 17.2 19.5 15.7 19.9 14.3 17.7 19.8 19.4 18.8 ...
 $ Aneurisms_q1 : int  114 148 196 199 188 260 135 216 117 188 ...
 $ Aneurisms_q2 : int  140 209 251 140 120 266 98 238 215 144 ...
 $ Aneurisms_q3 : int  202 248 122 233 222 320 154 279 181 192 ...
 $ Aneurisms_q4 : int  237 248 177 220 228 294 245 251 272 185 ...
</code></pre>
<p>We see the first two columns (ID and Gender) are type factor. Factors are a very useful datatype in R and we will look at them in detail next. The Group column is a logical datatype (values are True or False). 5 columns (BloodPressure, Aneurisms_q1-4) are all type integer. One column is type num (Age).</p>
<h3 id="addressing-data">Addressing data</h3>
<p>There are 3 main ways to address data in a data frame: * By Index * By Logical vector * By Name (columns only)</p>
<h4 id="by-index">By Index</h4>
<p>We can see the dimensions, or <a href="../../gloss.html#shape">shape</a>, of the data frame like this:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(dat)</code></pre>
<pre class="output"><code>[1] 100   9
</code></pre>
<p>This tells us that our data frame, <code>dat</code>, has 100 rows and 9 columns.</p>
<p>If we want to get a single value from the data frame, we can provide an <a href="reference.html#index">index</a> in square brackets, just as we do in math:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># first value in dat</span>
dat[<span class="dv">1</span>, <span class="dv">1</span>]</code></pre>
<pre class="output"><code>[1] Sub001
100 Levels: Sub001 Sub002 Sub003 Sub004 Sub005 Sub006 Sub007 ... Sub100
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># middle value in dat</span>
dat[<span class="dv">30</span>, <span class="dv">4</span>]</code></pre>
<pre class="output"><code>[1] 108
</code></pre>
<p>An index like <code>[30, 4]</code> selects a single element of a data frame, but we can select whole sections as well. For example, we can select the first ten patients (rows) of values for the first four observations (columns) like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">dat[<span class="dv">1</span>:<span class="dv">10</span>, <span class="dv">1</span>:<span class="dv">4</span>]</code></pre>
<pre class="output"><code>       ID Gender      Group BloodPressure
1  Sub001      m    Control           132
2  Sub002      m Treatment2           139
3  Sub003      m Treatment2           130
4  Sub004      f Treatment1           105
5  Sub005      m Treatment1           125
6  Sub006      M Treatment2           112
7  Sub007      f    Control           173
8  Sub008      m Treatment2           108
9  Sub009      m Treatment2           131
10 Sub010      f    Control           129
</code></pre>
<p>The <a href="reference.html#slice">slice</a> <code>1:4</code> means, &quot;Start at index 1 and go to index 4.&quot;</p>
<p>The slice does not need to start at 1, e.g. the line below selects rows 5 through 10:</p>
<pre class="sourceCode r"><code class="sourceCode r">dat[<span class="dv">5</span>:<span class="dv">10</span>, <span class="dv">1</span>:<span class="dv">4</span>]</code></pre>
<pre class="output"><code>       ID Gender      Group BloodPressure
5  Sub005      m Treatment1           125
6  Sub006      M Treatment2           112
7  Sub007      f    Control           173
8  Sub008      m Treatment2           108
9  Sub009      m Treatment2           131
10 Sub010      f    Control           129
</code></pre>
<p>We can use the function <code>c</code>, which stands for <strong>c</strong>ombine, to select non-contiguous values:</p>
<pre class="sourceCode r"><code class="sourceCode r">dat[<span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">8</span>, <span class="dv">37</span>, <span class="dv">56</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">6</span>)]</code></pre>
<pre class="output"><code>       ID      Group Aneurisms_q1
3  Sub003 Treatment2          196
8  Sub008 Treatment2          216
37 Sub037 Treatment2          161
56 Sub056 Treatment2          199
</code></pre>
<p>We also don't have to provide a slice for either the rows or the columns. If we don't include a slice for the rows, R returns all the rows; if we don't include a slice for the columns, R returns all the columns. If we don't provide a slice for either rows or columns, e.g. <code>dat[, ]</code>, R returns the full data frame.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># All columns from row 5</span>
dat[<span class="dv">5</span>, ]</code></pre>
<pre class="output"><code>      ID Gender      Group BloodPressure  Age Aneurisms_q1 Aneurisms_q2
5 Sub005      m Treatment1           125 19.9          188          120
  Aneurisms_q3 Aneurisms_q4
5          222          228
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># All rows from column 4</span>
dat[, <span class="dv">4</span>]</code></pre>
<pre class="output"><code>  [1] 132 139 130 105 125 112 173 108 131 129 126  96  77 158  81 137 147
 [18] 130 105  92 111 122  97 118  82 123 126  94 135 108 133 108 122 134
 [35] 145 133  90 118 113 115 142 114 139  90 126 109 125  99 122 111 109
 [52] 134 113 105 125 123 155 117 116 133  94 106 144 149 108 116 136  98
 [69] 148  74 147 116 133  97 132 153 151 121 116 104 111  62 124 124 109
 [86] 117  90 158 113 150 115  83 116 141 108 102  90 133  83 122
</code></pre>
<h4 id="logical-adressing">Logical adressing</h4>
<p>We have seen how to address data structures using an index. Logical addressing is another useful approach.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">10</span>,<span class="dv">15</span>,<span class="dv">13</span>,<span class="dv">17</span>)

x[<span class="kw">c</span>(<span class="ot">TRUE</span>,<span class="ot">TRUE</span>,<span class="ot">TRUE</span>,<span class="ot">FALSE</span>,<span class="ot">FALSE</span>,<span class="ot">FALSE</span>,<span class="ot">FALSE</span>)]</code></pre>
<pre class="output"><code>[1] 5 3 7
</code></pre>
<p>Logical vectors can be created using <code>Relational Operators</code> e.g. <code>&lt; , &gt; ,  == , !=</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &gt;<span class="st"> </span><span class="dv">10</span></code></pre>
<pre class="output"><code>[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE
</code></pre>
<h4 id="by-name">By Name</h4>
<p>Columns in a dataframe can be named. In our case these names came from the header row of the csv file. Column names can be listed with the <code>names()</code> command.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(dat)</code></pre>
<pre class="output"><code>[1] &quot;ID&quot;            &quot;Gender&quot;        &quot;Group&quot;         &quot;BloodPressure&quot;
[5] &quot;Age&quot;           &quot;Aneurisms_q1&quot;  &quot;Aneurisms_q2&quot;  &quot;Aneurisms_q3&quot; 
[9] &quot;Aneurisms_q4&quot; 
</code></pre>
<p>Columns can be addressed using the <code>$</code> operator</p>
<pre class="sourceCode r"><code class="sourceCode r">dat$Gender</code></pre>
<pre class="output"><code>  [1] m m m f m M f m m f m f f m m m f m m F f m f f m M M f m f f m m m m
 [36] f f m M m f m m m f f M M m m m f f f m f m m m f f f f M f m f f M m
 [71] m m F m m f M M M f m M M m m f f f m m f m F f m m F m M M
Levels: F f M m
</code></pre>
<h4 id="challenge-1">Challenge</h4>
<p>A subsection of a data frame is called a <a href="../../gloss.html#slice">slice</a>. We can take slices of character vectors as well:</p>
<pre class="sourceCode r"><code class="sourceCode r">element &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;o&quot;</span>, <span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>, <span class="st">&quot;g&quot;</span>, <span class="st">&quot;e&quot;</span>, <span class="st">&quot;n&quot;</span>)
<span class="co"># first three characters</span>
element[<span class="dv">1</span>:<span class="dv">3</span>]</code></pre>
<pre class="output"><code>[1] &quot;o&quot; &quot;x&quot; &quot;y&quot;
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># last three characters</span>
element[<span class="dv">4</span>:<span class="dv">6</span>]</code></pre>
<pre class="output"><code>[1] &quot;g&quot; &quot;e&quot; &quot;n&quot;
</code></pre>
<ol style="list-style-type: decimal">
<li><p>If the first four characters are selected using the slice <code>element[1:4]</code>, how can we obtain the first four characters in reverse order?</p></li>
<li><p>What is <code>element[-1]</code>? What is <code>element[-4]</code>? Given those answers, explain what <code>element[-1:-4]</code> does.</p></li>
</ol>
<p>Index addressing and Logical addressing can be combined.</p>
<ol start="3" style="list-style-type: decimal">
<li>Using Index addressing for the columns and Logical addressing for the rows, select all the rows with lower case &quot;m&quot; for gender.</li>
</ol>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">#Create an index vector for the lower case &quot;m&quot;</span>
index&lt;-dat$Gender==<span class="st">&quot;m&quot;</span>
<span class="kw">head</span>(dat[index,]) <span class="co">#N.B, using head function to limit output</span></code></pre>
<pre class="output"><code>      ID Gender      Group BloodPressure  Age Aneurisms_q1 Aneurisms_q2
1 Sub001      m    Control           132 16.0          114          140
2 Sub002      m Treatment2           139 17.2          148          209
3 Sub003      m Treatment2           130 19.5          196          251
5 Sub005      m Treatment1           125 19.9          188          120
8 Sub008      m Treatment2           108 19.8          216          238
9 Sub009      m Treatment2           131 19.4          117          215
  Aneurisms_q3 Aneurisms_q4
1          202          237
2          248          248
3          122          177
5          222          228
8          279          251
9          181          272
</code></pre>
<h3 id="combining-indexing-and-assignment">Combining indexing and assignment</h3>
<p>We have seen how we slice data using indexing and how we can assign values to variables using the assignment operator. We can combine these two operations:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">10</span>,<span class="dv">15</span>,<span class="dv">13</span>,<span class="dv">17</span>)
x[x&gt;<span class="dv">10</span>] &lt;-<span class="st"> </span><span class="dv">0</span>

x</code></pre>
<pre class="output"><code>[1]  5  3  7 10  0  0  0
</code></pre>
<h3 id="challenge-2">Challenge</h3>
<ol style="list-style-type: decimal">
<li>Combine indexing and assigment to correct the Gender column so that all values are uppercase</li>
</ol>
<pre class="sourceCode r"><code class="sourceCode r">index_m&lt;-dat$Gender==<span class="st">&#39;m&#39;</span>
index_f&lt;-dat$Gender==<span class="st">&#39;f&#39;</span>

dat[index_m,<span class="dv">2</span>]&lt;-<span class="st">&#39;M&#39;</span>
dat[index_f,<span class="dv">2</span>]&lt;-<span class="st">&#39;F&#39;</span></code></pre>
<h3 id="factors">Factors</h3>
<p>This section is taken from the datacarpentry lessons git@github.com:datacarpentry/datacarpentry.git</p>
<p>Factors are used to represent categorical data. Factors can be ordered or unordered and are an important class for statistical analysis and for plotting.</p>
<p>Factors are stored as integers, and have labels associated with these unique integers. While factors look (and often behave) like character vectors, they are actually integers under the hood, and you need to be careful when treating them like strings.</p>
<p>Once created, factors can only contain a pre-defined set values, known as <em>levels</em>. By default, R always sorts <em>levels</em> in alphabetical order. For instance, if you have a factor with 2 levels:</p>
<pre class="sourceCode r"><code class="sourceCode r">sex &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;male&quot;</span>, <span class="st">&quot;female&quot;</span>, <span class="st">&quot;female&quot;</span>, <span class="st">&quot;male&quot;</span>))</code></pre>
<p>R will assign <code>1</code> to the level <code>&quot;female&quot;</code> and <code>2</code> to the level <code>&quot;male&quot;</code> (because <code>f</code> comes before <code>m</code>, even though the first element in this vector is <code>&quot;male&quot;</code>). You can check this by using the function <code>levels()</code>, and check the number of levels using <code>nlevels()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(sex)</code></pre>
<pre class="output"><code>[1] &quot;female&quot; &quot;male&quot;  
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nlevels</span>(sex)</code></pre>
<pre class="output"><code>[1] 2
</code></pre>
<p>Sometimes, the order of the factors does not matter, other times you might want to specify the order because it is meaningful (e.g., &quot;low&quot;, &quot;medium&quot;, &quot;high&quot;) or it is required by particular type of analysis. Additionally, specifying the order of the levels allows to compare levels:</p>
<pre class="sourceCode r"><code class="sourceCode r">food &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;low&quot;</span>, <span class="st">&quot;high&quot;</span>, <span class="st">&quot;medium&quot;</span>, <span class="st">&quot;high&quot;</span>, <span class="st">&quot;low&quot;</span>, <span class="st">&quot;medium&quot;</span>, <span class="st">&quot;high&quot;</span>))
<span class="kw">levels</span>(food)</code></pre>
<pre class="output"><code>[1] &quot;high&quot;   &quot;low&quot;    &quot;medium&quot;
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">food &lt;-<span class="st"> </span><span class="kw">factor</span>(food, <span class="dt">levels=</span><span class="kw">c</span>(<span class="st">&quot;low&quot;</span>, <span class="st">&quot;medium&quot;</span>, <span class="st">&quot;high&quot;</span>))
<span class="kw">levels</span>(food)</code></pre>
<pre class="output"><code>[1] &quot;low&quot;    &quot;medium&quot; &quot;high&quot;  
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">min</span>(food) ## doesn&#39;t work</code></pre>
<pre class="output"><code>Error in Summary.factor(structure(c(1L, 3L, 2L, 3L, 1L, 2L, 3L), .Label = c(&quot;low&quot;, : &#39;min&#39; not meaningful for factors
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">food &lt;-<span class="st"> </span><span class="kw">factor</span>(food, <span class="dt">levels=</span><span class="kw">c</span>(<span class="st">&quot;low&quot;</span>, <span class="st">&quot;medium&quot;</span>, <span class="st">&quot;high&quot;</span>), <span class="dt">ordered=</span><span class="ot">TRUE</span>)
<span class="kw">levels</span>(food)</code></pre>
<pre class="output"><code>[1] &quot;low&quot;    &quot;medium&quot; &quot;high&quot;  
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">min</span>(food) ## works!</code></pre>
<pre class="output"><code>[1] low
Levels: low &lt; medium &lt; high
</code></pre>
<p>In R's memory, these factors are represented by numbers (1, 2, 3). They are better than using simple integer labels because factors are self describing: <code>&quot;low&quot;</code>, <code>&quot;medium&quot;</code>, and <code>&quot;high&quot;</code>&quot; is more descriptive than <code>1</code>, <code>2</code>, <code>3</code>. Which is low? You wouldn't be able to tell with just integer data. Factors have this information built in. It is particularly helpful when there are many levels (like the subjects in our example data set).</p>
<h3 id="converting-factors">Converting factors</h3>
<p>If you need to convert a factor to a character vector, simply use <code>as.character(x)</code>.</p>
<p>Converting a factor to a numeric vector is however a little trickier, and you have to go via a character vector. Compare:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">2</span>))
<span class="kw">as.numeric</span>(f)               ## wrong! and there is no warning...</code></pre>
<pre class="output"><code>[1] 1 3 4 2
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.numeric</span>(<span class="kw">as.character</span>(f)) ## works...</code></pre>
<pre class="output"><code>[1]  1  5 10  2
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.numeric</span>(<span class="kw">levels</span>(f))[f]    ## The recommended way.</code></pre>
<pre class="output"><code>[1]  1  5 10  2
</code></pre>
<h3 id="challenge-3">Challenge</h3>
<p>The function <code>table()</code> tabulates observations and can be used to create bar plots quickly. For instance:</p>
<pre class="sourceCode r"><code class="sourceCode r">## Question: How can you recreate this plot but by having &quot;control&quot;
## being listed last instead of first?
exprmt &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;treat1&quot;</span>, <span class="st">&quot;treat2&quot;</span>, <span class="st">&quot;treat1&quot;</span>, <span class="st">&quot;treat3&quot;</span>, <span class="st">&quot;treat1&quot;</span>, <span class="st">&quot;control&quot;</span>,
                   <span class="st">&quot;treat1&quot;</span>, <span class="st">&quot;treat2&quot;</span>, <span class="st">&quot;treat3&quot;</span>))
<span class="kw">table</span>(exprmt)</code></pre>
<pre class="output"><code>exprmt
control  treat1  treat2  treat3 
      1       4       2       2 
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">barplot</span>(<span class="kw">table</span>(exprmt))</code></pre>
<p><img src="fig/01-starting-with-data-unnamed-chunk-35-1.png" title="plot of chunk unnamed-chunk-35" alt="plot of chunk unnamed-chunk-35" style="display: block; margin: auto;" /></p>
<!---

~~~{.r}
exprmt <- factor(exprmt, levels=c("treat1", "treat2", "treat3", "control"))
barplot(table(exprmt))
~~~

<img src="fig/01-starting-with-data-unnamed-chunk-36-1.png" title="plot of chunk unnamed-chunk-36" alt="plot of chunk unnamed-chunk-36" style="display: block; margin: auto;" />
--->
<h3 id="removing-levels-from-a-factor">Removing levels from a factor</h3>
<p>In the previous challenge we updated the data for Gender. R still thinks the levels &quot;m&quot; and &quot;f&quot; are valid for the Gender data.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(dat$Gender)</code></pre>
<pre class="output"><code>[1] &quot;F&quot; &quot;f&quot; &quot;M&quot; &quot;m&quot;
</code></pre>
<p>The <code>droplevels</code> function will remove any unused levels</p>
<pre class="sourceCode r"><code class="sourceCode r">dat&lt;-<span class="kw">droplevels</span>(dat)
<span class="kw">levels</span>(dat$Gender)</code></pre>
<pre class="output"><code>[1] &quot;F&quot; &quot;M&quot;
</code></pre>
<h3 id="manipulating-data">Manipulating Data</h3>
<p>Now let's perform some common mathematical operations to learn about our inflammation data. When analyzing data we often want to look at partial statistics, such as the maximum value per patient or the average value per eye. One way to do this is to select the data we want to create a new temporary data frame, and then perform the calculation on this subset:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># first row, columns 6 to 9</span>
patient_1 &lt;-<span class="st"> </span>dat[<span class="dv">1</span>, <span class="dv">6</span>:<span class="dv">9</span>]
<span class="co"># max aneurism for patient 1</span>
<span class="kw">max</span>(patient_1)</code></pre>
<pre class="output"><code>[1] 237
</code></pre>
<p>We don't actually need to store the row in a variable of its own. Instead, we can combine the selection and the function call:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># max inflammation for patient 2</span>
<span class="kw">max</span>(dat[<span class="dv">2</span>, <span class="dv">6</span>:<span class="dv">9</span>])</code></pre>
<pre class="output"><code>[1] 248
</code></pre>
<p>R also has functions for other commons calculations, e.g. finding the minimum, mean, median, and standard deviation of the data:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># minimum number of aneurisms in quadrant 1</span>
<span class="kw">min</span>(dat[, <span class="dv">6</span>])</code></pre>
<pre class="output"><code>[1] 65
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># mean number of aneurisms in quadrant 1</span>
<span class="kw">mean</span>(dat[,<span class="dv">6</span>])</code></pre>
<pre class="output"><code>[1] 158.84
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># median number of aneurisms in quadrant 1</span>
<span class="kw">median</span>(dat[, <span class="dv">6</span>])</code></pre>
<pre class="output"><code>[1] 158
</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># standard number of aneurisms in quadrant 1</span>
<span class="kw">sd</span>(dat[, <span class="dv">6</span>])</code></pre>
<pre class="output"><code>[1] 41.52952
</code></pre>
<p>What if we need the maximum aneurisms for all patients, or the average for each eye? As the diagram below shows, we want to perform the operation across a margin of the data frame:</p>
<p><img src="fig/r-operations-across-axes.svg" alt="Operations Across Axes" /></p>
<p>To support this, we can use the <code>apply</code> function.</p>
<blockquote>
<p><strong>Tip:</strong> To learn about a function in R, e.g. <code>apply</code>, we can read its help documention by running <code>help(apply)</code> or <code>?apply</code>.</p>
</blockquote>
<p><code>apply</code> allows us to repeat a function on all of the rows (<code>MARGIN = 1</code>) or columns (<code>MARGIN = 2</code>) of a data frame.</p>
<p>Thus, to obtain the average inflammation of each patient we will need to calculate the mean of all of the rows (<code>MARGIN = 1</code>) of the data frame.</p>
<pre class="sourceCode r"><code class="sourceCode r">avg_patient_aneurisms &lt;-<span class="st"> </span><span class="kw">apply</span>(dat[,<span class="dv">6</span>:<span class="dv">9</span>], <span class="dv">1</span>, mean)</code></pre>
<p>And to obtain the average inflammation of each eye we will need to calculate the mean of all of the columns (<code>MARGIN = 2</code>) of the data frame.</p>
<pre class="sourceCode r"><code class="sourceCode r">avg_eye_aneurisms &lt;-<span class="st"> </span><span class="kw">apply</span>(dat[,<span class="dv">6</span>:<span class="dv">9</span>], <span class="dv">2</span>, mean)</code></pre>
<p>Since the second argument to <code>apply</code> is <code>MARGIN</code>, the above command is equivalent to <code>apply(dat, MARGIN = 2, mean)</code>. We'll learn why this is so in the next lesson.</p>
<blockquote>
<p><strong>Tip:</strong> Some common operations have more efficient alternatives. For example, you can calculate the row-wise or column-wise means with <code>rowMeans</code> and <code>colMeans</code>, respectively.</p>
</blockquote>
<h4 id="key-points">Key Points</h4>
<ul>
<li>Use <code>variable &lt;- value</code> to assign a value to a variable in order to record it in memory.</li>
<li>Objects are created on demand whenever a value is assigned to them.</li>
<li>The function <code>dim</code> gives the dimensions of a data frame.</li>
<li>Use <code>object[x, y]</code> to select a single element from a data frame.</li>
<li>Use <code>from:to</code> to specify a sequence that includes the indices from <code>from</code> to <code>to</code>.</li>
<li>All the indexing and slicing that works on data frames also works on vectors.</li>
<li>Use <code>#</code> to add comments to programs.</li>
<li>Use <code>mean</code>, <code>max</code>, <code>min</code> and <code>sd</code> to calculate simple statistics.</li>
<li>Use <code>apply</code> to calculate statistics across the rows or columns of a data frame.</li>
</ul>
<h4 id="next-steps">Next Steps</h4>
<p>Our work so far has looked at the data from the first site, we have 4 samples from other locations. We would like to check the others the same way, but typing in the same commands repeatedly is tedious and error-prone. Since computers don't get bored (that we know of), we should create a way to do a complete analysis with a single command, and then figure out how to repeat that step once for each file. These operations are the subjects of the next two lessons.</p>
        </div>
      </div>
      <div class="footer">
        <a class="label swc-blue-bg" href="http://software-carpentry.org">Software Carpentry</a>
        <a class="label swc-blue-bg" href="https://github.com/swcarpentry/r-novice-inflammation">Source</a>
        <a class="label swc-blue-bg" href="mailto:admin@software-carpentry.org">Contact</a>
        <a class="label swc-blue-bg" href="LICENSE.html">License</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="http://software-carpentry.org/v5/js/jquery-1.9.1.min.js"></script>
    <script src="http://software-carpentry.org/v5/js/bootstrap/bootstrap.min.js"></script>
  </body>
</html>
